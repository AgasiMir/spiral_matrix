import asyncio
import logging
from functools import wraps

from aiohttp import (
    ClientSession,
    ClientResponseError,
    ClientConnectorError,
    ServerDisconnectedError,
    ClientPayloadError,
    ClientTimeout as AiohttpTimeout,
)

# === Настройка логирования ===
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(message)s",
    handlers=[
        logging.FileHandler("matrix_app.log", encoding="utf-8"),
        logging.StreamHandler(),  # выводит логи и в консоль
    ],
)
logger = logging.getLogger(__name__)


# === Константы ===
SOURSE_URL: str = (
    "https://rawgithubusercontent.com/avito-tech/python-trainee-assignment/main/matrix.txt"
)

TRAVERSAL: list[int] = [
    10,
    50,
    90,
    130,
    140,
    150,
    160,
    120,
    80,
    40,
    30,
    20,
    60,
    100,
    110,
    70,
]


# === Декоратор retry для async-функций ===
def retry(_func=None, *, max_retries: int = 3, backoff_factor: float = 1.0):
    """
    Декоратор для повторных попыток вызова асинхронной функции.
    Повторяет вызов при любых исключениях, с экспоненциальной задержкой.
    """

    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(max_retries):
                try:
                    return await func(*args, **kwargs)
                except ClientResponseError as e:
                    # Не повторяем клиентские ошибки (4xx), кроме 429
                    if 400 <= e.status < 500 and e.status != 429:
                        logger.warning("Клиентская ошибка %d — не повторяем", e.status)
                        raise
                    last_exception = e
                except Exception as e:
                    last_exception = e

                logger.warning(
                    "Попытка %d из %d не удалась: %s",
                    attempt + 1,
                    max_retries,
                    last_exception,
                )

                if attempt < max_retries - 1:
                    delay = backoff_factor * (2**attempt)
                    logger.info("Ждём %.1f сек. перед повтором...", delay)
                    await asyncio.sleep(delay)
                else:
                    logger.error("Все %d попыток провалились.", max_retries)
                    raise last_exception

        return wrapper

    if _func is None:
        return decorator
    return decorator(_func)


# === Основные функции ===
def spiral_counter_clockwise(matrix: list[list[int]]) -> list[int]:
    """
    Обходит матрицу по спирали против часовой стрелки, используя NumPy.
    """
    if not matrix or not matrix[0]:
        return []

    result: list[int] = []
    top, bottom = 0, len(matrix) - 1
    left, right = 0, len(matrix[0]) - 1

    while top <= bottom and left <= right:
        # Левая граница: сверху вниз
        for i in range(top, bottom + 1):
            result.append(matrix[i][left])

        # Нижняя граница: слева направо (кроме первого элемента)
        if left < right:
            for i in range(left + 1, right + 1):
                result.append(matrix[bottom][i])

        # Правая граница: снизу вверх (кроме первого элемента)
        if top < bottom and left < right:
            for i in range(bottom - 1, top - 1, -1):
                result.append(matrix[i][right])

        # Верхняя граница: справа налево (кроме первого и последнего элементов)
        if top < bottom - 1 and left < right:
            for i in range(right - 1, left, -1):
                result.append(matrix[top][i])

        # Сужаем границы
        top += 1
        bottom -= 1
        left += 1
        right -= 1

    return result


def make_matrix(data: str) -> list[list[int]]:
    """
    Парсит строку с разделителями '|' и возвращает матрицу.
    """
    numbers_and_lines: list[str] = [i.strip() for i in data.split("|")]
    lines: list[str] = [line for line in numbers_and_lines if not line.isdigit()]
    numbers: list[int] = [int(num) for num in numbers_and_lines if num.isdigit()]

    size: int = len(lines) - 1

    # создание матрицы
    matrix: list[list[int]] = [numbers[i * size : size + size * i] for i in range(size)]

    return matrix


@retry(max_retries=3, backoff_factor=1.0)
async def fetch_matrix(session: ClientSession, url: str) -> str:
    """
    Загружает тело ответа по URL.
    Использует retry при временных ошибках.
    """
    logger.info("Запрос к %s", url)
    async with session.get(url) as response:
        if 400 <= response.status < 600:
            raise ClientResponseError(
                request_info=response.request_info,
                history=response.history,
                status=response.status,
                message=f"HTTP {response.status}: ошибка сервера или клиента",
            )
        text: str = await response.text()
        logger.info("Успешно загружено %d символов", len(text))
        return text


async def get_matrix(url: str) -> list[int]:
    """
    Основная функция: загружает, парсит и обходит матрицу.
    """
    logger.info("Начало обработки матрицы: %s", url)
    timeout = AiohttpTimeout(total=10)
    async with ClientSession(timeout=timeout) as session:
        try:
            response_body = await fetch_matrix(session, url)
        except Exception as e:
            logger.error("Не удалось загрузить матрицу: %s", e)
            raise

    try:
        matrix: list[list[int]] = make_matrix(response_body)
        logger.info("Матрица распаршена: %d×%d", len(matrix), len(matrix[0]))
        result: list[int] = spiral_counter_clockwise(matrix)
        logger.info("Спиральный обход завершён: %d элементов", len(result))
        return result
    except ValueError as e:
        logger.error("Ошибка при парсинге чисел: %s", e)
        raise ValueError(f"Ошибка при парсинге матрицы: {e}")
    except Exception as e:
        logger.error("Ошибка при обработке матрицы: %s", e)
        raise RuntimeError(f"Ошибка при обработке матрицы: {e}")


# === Точка входа ===
if __name__ == "__main__":

    async def main():
        try:
            result: list[int] = await get_matrix(SOURSE_URL)
            print("Результат:", result)
            assert result == TRAVERSAL, f"Ожидалось {TRAVERSAL}, получено {result}"
            print("✅ Тест пройден!")
        except Exception as e:
            logger.critical("Программа завершилась с ошибкой: %s", e)
            print(f"❌ Ошибка: {e}")

    asyncio.run(main())


__all__: list[str] = ["get_matrix", "spiral_counter_clockwise", "make_matrix"]
